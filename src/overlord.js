var output = require("output");
var config = require("config");
var validStances = ["NUKE", "NUKE_THREAT", "UNDER_ASSAULT", "ALERT", "SIEGE", "STANDBY", "NO_STANCE"];
var overlord = {
	/*
	 * returns an array of HQ rooms
	 * @Param {Game.spawns} spawns
	 * RETURN {Set} rooms - names of rooms running overlord AI
	 */
	getRoomsForAnalysis: function(spawns){
		var rooms;
		for(var name in spawns){
			var spawn = Game.spawns[name];
			if(spawn.room.controller && spawn.room.controller.my){
				rooms.push(spawn.room.name);
			}
		}
		Memory.overlord.coreRooms = rooms;
		return rooms;
	},
	/*
	 * Calculates the state of a room
	 * @param {String} roomName - room to run analysis for
	 * @param {Set} rooms - Set of all rooms running analytics
	 *                      Needed for reactive behavior
	 */
	calculateRoomStates: function(roomName){
		var errorstring = "Room " + roomName + "Encountered an error initializing memory";
        try{
            var room = Game.rooms[roomName];
            // 	Initialize room in memory if it doesn't exist
            this.initOverlordRoomMemory(roomName);
            // 	Need to have distances to other rooms for proximity based behavior
            errorstring = "Room " + roomName + "Encountered an error finding allied locations";
            this.findAlliedLocations(roomName);
            // 	Military stance check
            errorstring = "Room " + roomName + "Encountered an error determining combat stance";
            this.determineStance(roomName);
            //	Economic stance check
        }catch(e){
            output.log("overlord", 2, errorstring, e); 
        }
	},
	/* TODO
	 * Establishes stance for room (typically autogenerated)
	 *  Determined by hostile activity (and determines other behavior)
	 * @param {String} roomName - name of room to determine stance for
	 * @param {Set} rooms - set of all HQ rooms (for reactive behavior)
	 * Stance States:
	 *
	 *  NUKE:
	 *      Status:     Room is under nuclear attack
     *      Trigger:    Nuke(s) detected in room
     *      Timeout:    No nuke detected
     *      Behavior:   Build ramparts over critical structures under nuke
     *                  Move Sub-critical structures under nuke
     *                  Dump Lab energy/resources to storage
     *					TODO: Write calculator for which structures to move
     *  NUKE_THREAT:
     *      Status:     Room is under threat of nuclear attack
     *      Trigger:    Manually set
     *                  NUKE Stance detected in nearby rooms
     *      Timeout:    Indefinite / 10k ticks
     *      Behavior:   Build Ramparts over critical structures
     *                  Dump Lab energy/resources to storage
     *                      TODO: create critical structure priority list
     *                          Focus spawns, storages, towers, terminals
     *  UNDER_ASSAULT:
     *      Status:     Room is currently under direct assault (not by invaders)
     *      Trigger:    Hostile creeps (not on IFF) in room
     *                  Hostile creeps (not on IFF) approaching from prox. rooms
     *                  TODO: Units killed in this or proximate rooms when hostiles detected
     *      Timeout:    100 ticks (Drops to alert state)
     *      Behavior:   Upgrading stops (blocks modes expand, resourcing, and GCL)
     *                  Remote mining in direction of attack paused
     *                  Locks ramparts and stations creeps in them
     *                  SCV Priority shifts to: Military Construction > Fortify > Else
     *                  
     *  ALERT:
     *      Status:     Room under immediate threat of attack
     *      Trigger:    Room exiting assault status
     *                  ASSAULT stance detected in other room
     *		Timeout: 	2000 ticks (Creep life, plus some wiggle room)
     *		Behavior: 	Stockpile limit increased
     *					Small numbers of defensive ralliers spawn
     *					All ramparts lock
     *
     *	SEIGE:
     *		Status: 	Remote mining operations under attack
     *		Trigger: 	Baron AIs for remote rooms going into SEIGE stance
     *		Timeout: 	Hostile Units Killed
     *					1500 ticks
     *		Behavior: 	Strike Teams deployed based on hostile threatscore
     *					Remote mining in those rooms halted
     *
     *	STANDBY:
     *		Status: 	Room conducting normal operations
     *		Trigger: 	Default state
     *		Timeout: 	None
     *		Behavior: 	Determined by economic state
	 */
	determineStance: function(roomName, rooms){
		var old = Memory.overlord[roomName];		//	Short for OverlordData
		initialize(old);
	    var room = Game.rooms[roomName];
	    //  Nuke check is most important, so it's first
	    if(room.find(FIND_NUKES).length > 0){
	        return old.setStance("NUKE");
	    }
	    //  Check if anyone else is in NUKE stance
	    var nukeProx = nearbyRoomsInRangeInStance(roomName, old.nukeProxDist, "NUKE");
        if(!!nukeProx){
            return old.setStance("NUKE_THREAT", nukeProx);
        }
	    //  If I'm still in NUKE_THREAT, check for timeout
	    if(old.stance == "NUKE_THREAT"){
	        if(Game.time >= (old.stanceTime + nukeThreatTimeOut)){
	            old.setStance("NO_STANCE");
	        }else{
	            return;
	        }
	    }
	    //  If I'm under attack, go into UNDER_ASSAULT stance
	    if(roomIsUnderAttack(roomName)){
	        return old.setStance("UNDER_ASSAULT");
        }
        //	If I'm not IMMEDITALY under attack, check the UNDER_ASSAULT timeout
	    if(old.stance == "UNDER_ASSAULT"){
            if(Game.time >= (old.stanceTime + underAssaultTimeOut)){
                return old.setStance("ALERT");
            }else{
            	return;
            }
	    }
	    //	TODO:
	    //	If I'm under attack, determine the direction of the assault (Possibly under the mode specific functions?)
	    //	If I'm not under attack, check if my neighbors are-
	    var alertProx = nearbyRoomsInRangeInStance(roomName, old.alertProxDist, "UNDER_ASSAULT");
	    if(!!alertProx){
	    	return old.setStance("ALERT", alertProx);
	    }
	    if(supportRoomsAreInStance(roomName, "SEIGE")){
	    	return old.stanceTime("SEIGE");
	    }
	    //	If I'm in siege mode, check to see if I'm still being besieged
	    //	If I'm in standby and there's no need to update, just return, 
	    if(old.stance == "STANDBY"){
	    	return;
	    }
	    return old.setStance("STANDBY");
	},

	/*
	 * 	Part reference module - creates framework for overlord memory use later
	 * 	Doesn't overwrite anything that doesn't exist
	 * 	@param {string} roomName - Name of room for which to initialize memory.
	 */
    initOverlordRoomMemory: function(roomName){
        if(!Memory.overlord[roomName]){
            var roomData = {
            	//	High Level stuff
	            stance: null,       	//  Determines defensive behavior
	            stanceTime: 0,      	//  When room entered stance
	            stanceProx: false,		//	Whether current stance was triggered by proximity behavior (otherwise the name of the trigger room)
	            mode: null,         	//  Economic mode
	            modeTime: 0,			//	When room entered mode
	            RCL: 0,					// 	Level of room controller
	            wallPerc: 0,			//	Ideal Percentage of wall capacity for room
				remoteRooms: [],   		//  List of remote mining room names
				oRDists: [],			// 	Array of other HQ rooms and the distances to them
				dBuff: 0,				//	Desired energy buffer for the room

				//	Defense Related Data
				thLim: 0,				//	Enemy threat limit before response
	            dexits: {},				//	Dangerous (attacked) exits (directions not to mine in)
	            tdmode: null,			//	Tower Defense Mode (Determines targetting);
	            tdtarget: null,			//	Id of current target
	            tdlasthits: 0,			//	Hits of target last tick (for stalemate checking);
	            tdlast: null,			//	Id of last target (used when tdtarget is null to prevent reselecting the same target)

	            //	TaskList related data
	            spwnQueue: [],			//	SpawnQueue for the room
	            taskList: [],			//	What needs building. Objects are {id, amount required, type (extension, storage, military, etc.), pos}

	            //	Caches
	            strCache: [],			//	List of all structure ids in the room
	            srcCache: [],			//	Cache of source information objects
	            wallCache: [],			//	Cache of all wall ids in room

				//	Creep related Data
	            creepCount: 0,       	//  Creeps owned by this room
	            creepIds: [],			//	Ids of all creeps based in this room

	            //	Link Related Data
	            links: [],				//	ObjectIds of all links in the room
	            sndLinks: [],			// 	ObjectIds of send only links
	            ctlLink: null,			// 	ObjectId of controller link (essentially receive only)

	            //	Overlord Behavior Defaults
	            nukeThreatTimeout: 10000,     		//	Timeout in ticks for nuke threat
	            nukeProxDist: 5,
	    		underAssaultTimeout: 100,			//	Timeout in ticks for room to no longer be under assault
	    		alertTimeout: 1500,					//	Timeout in ticks for a room to stand down from alert
	    		alertProxDist: 5,					//	Default linear range in which an assault will trigger that room's alert
	    		siegeTimeout: 1000 					//	Timeout for 
	        };
	        Memory.overlord[roomName] = roomData;
        }
    },
	/*	TODO
	 * 	This module is supposed to be called when a creep is in "idle" taskstate
	 * 	@param {Creep} creep - creep in idle state
	 */
	getNewTask: function(creep){
		
	}

};
module.exports = overlord;
/*
 *	Initializes setters for the overlord data object's stances
 */
function initialize(overlordDataObject){
	overlordDataObject.setStance = function(stance, proxTriggered = false){
		if(validStances.includes(stance)){
			old.stance = stance;
			old.stanceTime = Game.time;
			old.stanceProx = proxTriggered;
			return stance;
		}else{
			throw new Error("INVALID STANCE");
		}
	};
}
/*
 *	Determines if any self-HQs within the given range are in a certain stance
 *	@param {String} roomName
 *	@param {integer} range - linear range between rooms
 *	@param {String} stance
 */
function nearbyRoomsInRangeInStance(roomName, range, stance){
	var old = Memory.overlord[roomName];
	if(!validStances.includes(stance)){
		throw new Error("INVALID STANCE");
	}
	for(var i in old.oRDists){
		if(i.distance <= range && roomIsInStance(i.name, stance)){
			return i.name;
		}
	}
	return false;
}
/*
 *	Determines if any sub rooms within the given range are in a certain stance
 *	@param {String} roomName
 *	@param {String} stance
 */
function supportRoomsAreInStance(roomName, stance){
	var old = Memory.overlord[roomName];
	for(var i in old.remoteRooms){
		if(roomIsInStance(i.name, stance)){
			return true;
		}
	}
	return false;
}
/*
 *	Checks if the room is in the stance. If so, true. Anything else is false.
 *	@param {String} roomName
 * 	@param {String} stance
 */
function roomIsInStance(roomName, stance){
	if(!!Memory.overlord && !!Memory.overlord[roomName] && Memory.overlord[roomName].stance == stance){
		return true;
	}
	return false;
}
/*
* Determines if room is under immediate or threatened attack
*      Checks own room
*      Checks immediately approximate rooms (regardless of if they're mine
*  		but not if they're hostile)
*		TODO: Check for spikes in hostile room creep counts
*/
function roomIsUnderAttack(roomName){
	var combat = require("combat");
	var thisRoomTargetList = combat.IFFSafeTargetList(Game.rooms[roomName], false);
	if(thisRoomTargetList > 0){
	    return true;   
	}
	var nearbyRooms = Game.map.describeExits(roomName);
	for (const key of Object.keys(nearbyRooms)) {
	    const nearbyRoom = obj[key];
	    if((!nearbyRoom.controller || nearbyRoom.controller.my) && (combat.IFFSafeTargetList(nearbyRoom, false).length !== 0)) {
	    	return true;
	    }
	}
	return false;
}
/*
	 *	Finds the distances to other HQ rooms
	 *	@param {String} roomName - room to calculate distances for
	 */
function findAlliedLocations(roomName){
	var oRDists = [];
	for(var name in Memory.overlord.coreRooms){
		var distance = Game.map.getRoomLinearDistance(roomName, name);
		oRDists.push({name:name, distance:distance});
	}
	Memory.overlord[roomName].oRDists = oRDists;
	return oRDists;
}